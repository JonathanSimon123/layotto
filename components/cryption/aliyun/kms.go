// Code generated by github.com/seeflood/protoc-gen-p6 .

// Copyright 2021 Layotto Authors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package aliyun

import (
	"context"
	"fmt"
	"sync"

	"mosn.io/layotto/components/pkg/actuators"

	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	kms20160120 "github.com/alibabacloud-go/kms-20160120/v3/client"
	"github.com/alibabacloud-go/tea/tea"

	log "mosn.io/layotto/kit/logger"

	"mosn.io/layotto/components/cryption"
)

const (
	componentName = "kms-aliyun"
)

var (
	once               sync.Once
	readinessIndicator *actuators.HealthIndicator
	livenessIndicator  *actuators.HealthIndicator
)

func init() {
	readinessIndicator = actuators.NewHealthIndicator()
	livenessIndicator = actuators.NewHealthIndicator()
}

type cy struct {
	client *kms20160120.Client
	keyID  string
	log    log.Logger
}

/*
refer: https://help.aliyun.com/document_detail/611325.html
*/
func NewCryption() cryption.CryptionService {
	once.Do(func() {
		indicators := &actuators.ComponentsIndicator{ReadinessIndicator: readinessIndicator, LivenessIndicator: livenessIndicator}
		actuators.SetComponentsIndicator(componentName, indicators)
	})
	cryption := &cy{
		log: log.NewLayottoLogger("cryption/aliyun"),
	}
	log.RegisterComponentLoggerListener("cryption/aliyun", cryption)
	return cryption
}

func (k *cy) OnLogLevelChanged(outputLevel log.LogLevel) {
	k.log.SetLogLevel(outputLevel)
}

func (k *cy) Init(ctx context.Context, conf *cryption.Config) error {
	accessKey := conf.Metadata[cryption.ClientKey]
	secret := conf.Metadata[cryption.ClientSecret]
	region := conf.Metadata[cryption.Region]
	config := &openapi.Config{
		// your AccessKey ID
		AccessKeyId: tea.String(accessKey),
		// your AccessKey Secret
		AccessKeySecret: tea.String(secret),
		// Endpoint refer: https://api.aliyun.com/product/Kms
		RegionId: tea.String(region),
	}

	client, err := kms20160120.NewClient(config)
	if err != nil {
		readinessIndicator.ReportError(err.Error())
		livenessIndicator.ReportError(err.Error())
		return err
	}
	readinessIndicator.SetStarted()
	livenessIndicator.SetStarted()
	k.client = client
	k.keyID = conf.Metadata[cryption.KeyID]
	return nil
}

func (k *cy) Decrypt(ctx context.Context, request *cryption.DecryptRequest) (*cryption.DecryptResponse, error) {
	decryptRequest := &kms20160120.DecryptRequest{
		CiphertextBlob: tea.String(string(request.CipherText)),
	}
	decryptResp, err := k.client.Decrypt(decryptRequest)
	if err != nil {
		k.log.Errorf("fail decrypt data, err: %+v", err)
		return nil, fmt.Errorf("fail decrypt data with error: %+v", err)
	}
	resp := &cryption.DecryptResponse{KeyId: *decryptResp.Body.KeyId, KeyVersionId: *decryptResp.Body.KeyVersionId,
		RequestId: *decryptResp.Body.RequestId,
		PlainText: []byte(*decryptResp.Body.Plaintext)}
	return resp, nil
}

func (k *cy) Encrypt(ctx context.Context, request *cryption.EncryptRequest) (*cryption.EncryptResponse, error) {
	// if keyId specified, use request KeyId
	keyId := k.keyID
	if request.KeyId != "" {
		keyId = request.KeyId
	}
	encryptRequest := &kms20160120.EncryptRequest{
		KeyId:     tea.String(keyId),
		Plaintext: tea.String(string(request.PlainText)),
	}

	encryptResp, err := k.client.Encrypt(encryptRequest)
	if err != nil {
		k.log.Errorf("fail encrypt data, err: %+v", err)
		return nil, fmt.Errorf("fail encrypt data with error: %+v", err)
	}
	resp := &cryption.EncryptResponse{KeyId: *encryptResp.Body.KeyId, KeyVersionId: *encryptResp.Body.KeyVersionId,
		RequestId:  *encryptResp.Body.RequestId,
		CipherText: []byte(*encryptResp.Body.CiphertextBlob)}
	return resp, nil
}
